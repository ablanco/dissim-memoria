% Metodología e implementación

\chapter*{Implementación} \label{cap5}
\addcontentsline{toc}{chapter}{Implementación}

\begin{flushright}
\begin{minipage}{7.85cm}
    {\em Si necesitas más de tres niveles de indentación estás jodido, y
    deberías arreglar tu programa.} \\  Linus Torvalds
\end{minipage}
\end{flushright}

\vspace*{5mm}

\section*{Metodología}

Al ser este un proyecto de tamaño considerable, y al realizarse en grupo, es
necesario establecer una metodología para evitar el trabajo inútil o redundante.

Para organizar nuestro trabajo, y poder mantener siempre cierto control sobre la
evolución de la aplicación, nos hemos servido tanto de herramientas como de
algunas buenas prácticas.

Habiendo desarrollado nuestro proyecto en el marco del IV CUSL\footnote{Concurso
Universitario de Software Libre: \url{http://www.concursosoftwarelibre.org}}
hemos seguido una política de divulgación de la información y unos plazos de
entrega. Desde la organización del concurso pusieron a nuestra disposición una
forja, en concreto la forja
IRIS-Libre\footnote{\url{https://forja.rediris.es/projects/cusl4-catastrof/}},
gracias a la que pudimos agilizar y centralizar las labores de administración y
planificación del proyecto.

Además adoptamos una política de entrevistas frecuentes con los tutores para
así motivarnos y que nos aconsejaran sobre el mejor paso a seguir, o en dónde
deberíamos profundizar más, o cuándo seguir otras vías de investigación.

De esta manera teníamos objetivos a corto plazo, herramientas para la
planificación gracias al IV CUSL, y guía por parte de los tutores.

\subsection*{Metodologías Ágiles}

Una buena planificación no implica el éxito, pero por lo menos te asegura unos
resultados mínimos.

No hemos aplicado ninguna metodología en concreto, si no un conjunto de técnicas
y buenos métodos. Creemos en una metodología de desarrollo ágil.

\subsubsection*{Reuniones de Desarrollo}

Lo principal es la comunicación entre los desarrolladores, para ello decidimos
reunirnos y comentar las avances o principales problemas al menos dos veces a
la semana.

Las reuniones no tenían por qué ser en persona, ni muy formales, podían
realizarse a través de mensajería instantánea, ayudados con herramientas de
pizarras virtuales. De esta forma siempre se tiene una idea muy cercana del
desarrollo del proyecto sin perder mucho tiempo.

Además mantiene un fuerte lazo entre los desarrolladores y les permite ayudarse
unos a otros, evitando así estancamientos o frustraciones con problemas
difíciles.

\subsubsection*{Reuniones con los Tutores}

Nos reuníamos con nuestros tutores al menos dos veces al mes, dependiendo del
ritmo de trabajo y progresos. Estas reuniones eran de carácter informativo y
orientativo.

Las reuniones permiten un crecimiento guiado y controlado del producto final, y
un nivel de acabado mayor al centrarnos solo en las partes realmente importantes
de la investigación y el desarrollo para los objetivos del proyecto.

\subsubsection*{Sistema Incremental}

Lo principal era desarrollar una plataforma muy básica y sencilla donde se
pudieran llevar a cabo pruebas, y una vez completada, ir aumentando las
prestaciones en forma de módulos o complementos que fueran implementando las
funcionalidades deseadas.

Seguimos pues un modelo iterativo de desarrollo del software, que es el ciclo
de vida del software que probablemente mejor se adapte a metodologías ágiles.

% TODO esquema del ciclo de vida iterativo

\subsubsection*{Reparto de Tareas Dinámico}

El reparto de tareas equitativo y ágil es vital para mantener una buena
relación entre los desarrolladores, y para el adecuado progreso del proyecto.

Por ello es importante identificar las tareas a realizar e ir asignándolas a
los desarrolladores, de forma que ellos mismos puedan decidir cómo organizarse,
pero siempre teniendo en cuenta unos plazos finales.

El reparto no siempre es estático, puesto que las tareas se pueden alargar o
acortar debido a una mala estimación inicial, incluso a veces se pueden
reasignar o subdividir para agilizar el desarrollo.

Al haber más de un desarrollador en el proyecto hemos tendido un poco a la
especialización en las tareas. Si un desarrollador ha estado trabajando en una
parte, o tiene experiencia y aptitudes para determinado aspecto del desarrollo,
tendrá prioridad a la hora de asignar las tareas relacionadas.

Sin embargo, no se trata de dividir el proyecto en dos, puesto que siempre se
intenta que todos los desarrolladores estén implicados en todas las ramas.
Después de todo el objetivo final del proyecto es aprender y ampliar
conocimientos en todas las áreas que éste toca.

\subsection*{Forja IRIS-Libre}

RedIRIS proporciona un servicio de forja bajo el nombre de
IRIS-Libre\footnote{\url{https://forja.rediris.es/}}. Esta forja proporciona
alojamiento y herramientas a proyectos de Software Libre, y está asociada al
CUSL, dando alojamiento a los proyectos participantes.

\begin{figure}[H]
 \centering
 \includegraphics[width=30mm]{figuras/cap5/iris_libre.png}
 \caption{Logo de IRIS-Libre}
\end{figure}

Entre las herramientas para el alojamiento y la gestión de proyectos de carácter
colaborativo, y con vistas de crear una comunidad de desarrolladores, que
proporciona encontramos:

\subsubsection*{Subversion}

Como sistema de control de versiones la forja proporciona
SVN\footnote{\url{http://subversion.tigris.org/}}, este sistema permite llevar
un control sobre los cambios en el código, y obtener siempre una copia
actualizada con la última versión.

\begin{figure}[H]
 \centering
 \includegraphics[width=80mm]{figuras/cap5/svn.png}
 \caption{Logo de Subversion}
\end{figure}

Este tipo de software es imprescindible cuando se trabaja en grupo, pues
facilita la colaboración y permite mantener un orden en el desarrollo.

\subsubsection*{Planificador de Tareas}

La forja también dispone de una sencilla aplicación de control de tareas, que,
entre otras cosas, lo que permite es:

\begin{enumerate}
 \item Crear una tarea, con una breve descripción de la misma.
 \item Asignarlas a un desarrollador, y así poder repartir la carga de trabajo.
 \item Estimación del tiempo necesario, para poder planificar otras tareas.
 \item Progreso de la tarea, para poder hacer un seguimiento del progreso de la
 misma.
 \item Fecha límite de finalización.
\end{enumerate}

Con estos sencillos parámetros la herramienta incluso genera un diagrama de
Gantt para ayudarte con la planificación.

% TODO incluir dicho diagrama

\subsection*{Blog}
%Es una buena idea, porque al escribir articulos sirve para pensar mas en lo que
%haces y darle visiblidad, tambien era un requisito para el concurso de software
%libre y sirve para historico y desarrollo  del proyecto.
El llevar al día un blog \footnote{Simulación de Catástrofes
:\url{http://pfc.mensab.com/}} con las actualizaciones y las direcciones
generales sobre el desarrollo proyecto es algo altamente recomendable si se
quiere que el proyecto cree una comunidad, puesto que es una manera muy cómoda y
eficaz de mantener a la comunidad informada de los cambios y el estado del
proyecto.

Además también tiene otras implicaciones mas sutiles, por ejemplo permite
reafirmar las decisiones de diseño o de desarrollo tomadas a lo largo de la
implementación, puesto que queda constancia de las decisiones tomadas y las
razones para llevarlas a cabo.
\subsubsection*{Git}
%Nueva forma de ver las cosas, muchos commits, cambios muy controlaos,
%posibilidad de hacer ramas y mantener siempre una rama estable.
Git\footnote{Git - Fast Version Control System : \url{http://git-scm.com/}} es
un sistema de control de versiones distribuido que cambia un poco la filosofía
de SVN.

En cada proyecto colaborativo hay muchos desarrolladores que necesitan hacer
muchos cambios, probar muchas alternativas de su código y sin embargo mantener
a todo el mundo informado y a su vez mantener una rama estable de desarrollo.
SVN tiene problemas al gestionar las diferentes ramas de desarrollo, sobre todo
al unirlas.

Git soluciona este problema al fomentar los commits pequeños y una herramienta
de merge mas eficiente, que facilita trabajar con ramas, así todas las ramas
que tengan puntos en común pueden ser agrupadas y mantenidas muy fácilmente.

Con su sistema de log y sus normas de estilo siempre se podrá tener un
seguimiento de todos los cambios muy bien documentados del código, y una rama
master siempre funcional con muchas ramas de desarrollo alternativo y de fácil
integración.

Por estas razones decidimos migrar la aplicación a de SVN en RedIris a GIT en
Gitorious\footnote{Hosting de proyectos en GIT :
\url{http://gitorious.org/}} sin ningún esfuerzo y con muchísimas ventajas.
%Ahora pasamos a nuestra implementación concreta.
\section*{Implementación del Escenario de Simulación}
\section*{Implementación de los Agentes en la Simulación}
\subsection*{Agente Creador}
\subsection*{Agente Reloj}
%la necesidad de determinar el tiempo
\subsection*{Agentes Entorno}
\subsection*{Agentes Entrada de Agua}
\subsubsection{El Movimiento del Agua}
%Esto ya forma parte de las explicaciones
Por lo tanto, vistas nuestras limitaciones y sobre todo nuestra intención de un
modelo simple, a la hora de simular la propagación de una cierta cantidad de
agua sobre un terreno nos apoyamos en la iteración sobre el bucle del
comportamiento del agua, asumimos (que ya es mucho asumir), que en cada paso del
bucle, el agua se mueve hacia cuadrado adyacente que tenga una altura menor que
la propia, por lo tanto, el agua se moverá a tantas casillas adyacentes como
vueltas de el bucle. Así es de una manera muy simple, como simulamos la
propagación, dándole un valor de repetición a ese bucle.

Para el cálculo de este parámetro ............ bla bla bla %TODO

De esta forma tan simple, podemos controlar de una cierta manera razonable la
velocidad de propagación que tendrá el agua.

\subsection*{Agentes Peatón}
\subsubsection*{Actualización del estado}
%como determina el estado del peaton segun el entorno
\subsection*{Agentes Actualización}
\subsubsection*{Actualización entre entornos adyacentes}
%pasarse el aguita de unos a otros
\section*{Rejilla Hexagonal}
%Discretización del mundo real
Sobre la rejilla es donde se van a realizar todos los cálculos de la
simulación, por lo tanto dispone de todos los métodos para manipular
y obtener información contenida en ella.

También contiene funciones básicas como dado un punto obtener todos sus
adyacentes, o devolver todas las casillas que se puedan ver desde una posición
y un rango de visión.

También dispone de métodos para obtener caminos utilizando la adyacencia
hexagonal.
\subsection*{Matriz de Altura}
Una matriz de short solo puede albergar un rango de alturas desde +-32,767, que
dependiendo de la precisión puede ser mas o menos altura
\subsection*{Matriz de Agua}
%Hay que saber cuanta agua tenemos pa moverla
Al igual que la matriz de alturas se trara de una matriz de short del mimo
tamaño que la del entorno, pero esta contiene solo información de la cantidad
de agua que hay en esta casilla.

Este valor nunca podrá ser menor que cero.

Sumando las matrices de alturas y agua se obtiene la altura total del terreno.

Esta matriz es especifica de las inundaciones, puesto que para otras
catástrofes no es necesaria.
\subsection*{Matriz de Calles}
%Las calles hay que guardarlas en algun lao
Cada entorno necesita un mapa de la ciudad propio.

Este mapa solo se calculará en el inicio y no cambiará durante la simulación.

Para mejorar el tamaño en memoria usamos una matriz de short del mismo tamaño
que el entorno.
\subsubsection*{Tipos de Calles}
%Especificación de OSM
Para saber en que tipo de calle nos encontramos nos ayudamos de la información
de OSM que viene categorizada en grupos. Por cada grupo le asignamos un rango
de valores, teniendo en cuenta el numero de subgrupos.

Estos valores vienen identificados por medio de constantes globales y funciones
estáticas que nos devuelven el tipo concreto o los valores padre.
\subsubsection*{Prioridad de la información}
En cada casilla solo podemos almacenar un valor, por lo que la forma de
rellenar la matriz sobreescribe el valor de la matriz si el nuevo valor es
mayor que el viejo. Así nos aseguramos que la información que consideramos mas
prioritaria (de mayor valor) permanezca en la matriz
\subsubsection*{Intersecciones}
A veces es útil sobre todo para las calles saber cuando nos encontramos en un
cruce, para ello cuando nos encontramos un valor igual al que nosotros queremos
inserta, incrementamos en una unidad el valor, haciéndola impar, de esta forma
detectamos las intersecciones.
\subsection*{Coronas}
%mantenimiento actualizado de la corona
Al poder efectuar las simulaciones en mas de un entorno, tenemos que crear un
sistema de actualización a entornos vecinos, para facilitar esto disponemos de
las coronas, las coronas son vectores que contienen información de las casillas
adyacentes de los otros escenarios.

De esta forma, cuando se modifica la información de los limites del escenario,
es la corona la que se encarga de hacer el puente al siguiente escenario y las
actualizaciones necesarias.

De esta forma podemos hacer que los escenarios vean mas halla de su entorno.

\subsection*{Coordenada a Casilla y Viceversa} \label{coordToCasilla}
%conversión de una coordenada a un casilla, necesidad de los incrementos
Para pasar de una casilla a una coordenada utilizamos los incrementos.

\subsubsection*{Incrementos} \label{incrementos}
%perdida de datos, caminos no conexos, indeterminacion de las posisciones
Para poder interpolar la posición desde una casilla a una determinada
coordenada geográfica hemos optado por la técnica de los incrementos en vez de
complicados cálculos trigonométricos terrestres.

La técnica consiste en hallar la diferencia en grados decimales entre los
extremos del mapa y dividirla entre el numero de filas y columnas, con esto
obtenemos el incremento en Latitud o Longitud que hay entre cada casilla de
nuestra rejilla.

Debido a la forma de la rejilla hexagonal tenemos que tener en cuenta que las
filas impares tienen un offset de \begin{math} ^1/_2 \end{math} de un incremento
de latitud, y que las columnas tienen un incremento deEnvironment
\begin{math} ^3/_4 \end{math} el incremento de la longitud.

De esta forma tan sencilla podemos hacer las conversiones de casilla a
coordenada y viceversa.
\subsubsection*{Discretización}
El problema de coordenada a casilla es un poco mas complejo, puesto que al
tener una coordenada tenemos que aproximar a una casilla en concreto, para ello
primero realizamos una aproximación intentando averiguar la casilla en filas y
columnas, sin embargo la forma de las casillas es hexagonal, por lo que la
distancia al centro  no nos asegura que la casilla sea la correcta.

De esta forma perdemos un poco de información, pero los errores cometidos por
este sistema no superan el \begin{math} 0.7\% \end{math}

\subsection*{Especialización: Flood Hexagonal Grid}
%cambios de la rejilla por desastre
\section*{Implementación de la Elevación del Terreno}
%Solucion particular
Usamos los servicios web para extraer las alturas, un bucle por cada casilla
\subsection*{Patrón Fachada} %TODO
%Para poder utilizar todos los servicios web de alturas que hagan falta
Tenemos una fachada para implementar los posibles distintos servicios webs,
tienen que implementar estas funciones, tralaraaaaaa
\subsection*{Cache de alturas}
%Para mejorar la latencia de datos
Los servidores webs suelen ser muy lentos, y el volumen de datos que
necesitamos para la simulación puede ser muy grande.

Obtener todos estos datos cada vez que necesitemos simular un escenario no es
viable.

La solución que nosotros implementamos es almacenar en local los datos para
utilizarlos en posteriores simulaciones o incluso para poder reutilizarlos en
otras simulaciones.

La reutilización de datos se hace por medio de una interpolación (la media de
las casillas adyacentes) de datos en el caso de que nuestra base de datos tenga
la información suficiente.

En nuestra implementación optamos por usar  SQLite\footnote{SQLite Home Page :
\url{www.sqlite.org/}} porque sencillez para la
implementación y por la sencillez de la base de datos en si, que permite poder
moverla de un ordenador a otro con un coste mínimo de instalación al ser un
único fichero el que contiene todos los datos.

El principal problema de SQLite es que no puede albergar muchos datos, pero en
nuestro caso esto se puede resolver creando mas ficheros, y de esta forma
abordamos la escalabilidad.

La base de datos solo contiene una única tabla
\begin{center}
\begin{tabular}{ | l | c | r | }
\hline
Clave & Tipo \\ \hline
Lat & double \\ \hline
Long & double \\ \hline
Elev & double \\ \hline
\end{tabular}
\end{center}


\subsubsection*{Patrón fachada}
%pos una fachada pa poder usar distintos drivers
El diseño de la interfaz para trabajar con servicios web ha sido realizado
teniendo en cuenta el patrón fachada para poder incorporar nuevos servicios web
de altura.

Gracias a este diseño añadir nuevos servicios webs solo tienen el coste de
implementar la clase que cumpla los métodos de la interfaz.
\section*{Open Street Maps}
OSM tiene un servicio web, que a través de mandarle un url correctamente
formada devuelve un fichero XML que contiene toda la información de OSM sobre
unas coordinadas determinadas.

La url se compone de una {\bf Dirección Base} + {\bf Coordenada Inferior
 derecha} + {\bf Coordenada Superior Izquierda} y devolverá un fichero con el
mismo nombre que la petición.
\subsection*{Parseando XML}
%Leer y obtener información
La información viene codificada en un fichero XML siguiendo el estándar de OSM.
Para poder extraer la información es necesario primero parsear el fichero.
Para ello utilizamos JAXB\footnote{Java Architecture for XML Binding :
\url{https://jaxb.dev.java.net/}} que es una librería para recorrer ficheros
XML. 

Mientras realizamos el recorrido del fichero, hay que identificar la
información de las etiquetas y almacenarla en nuestra estructura de datos para
poder utilizarla de una forma mas cómoda.

El diseño de las clases para almacenar la información de OSM es muy parecido a
la jerarquía de información que sigue OSM.

Tenemos la clase principal OsmMap, que contiene toda la información que nos da
OSM.

{\bf OsmWay} para la etiqueta way y {\bf OsmMember} para los caminos
compuestos, {\bf OsmRelation} para los rios y parques, y {\bf OsmNode} para los
puntos simples y puntos de interés. 

Para almacenar la información extra tenemos OsmTag.
\subsubsection*{Filtro de información}
%Quedarnos con la información útil
OsmTag contiene dos atributos principales, clave y valor. Nos valemos de estos
dos atributos para almacenar la información extra que nos ofrece OSM, como el
nombre de la calle, el tipo de calle, o si se trata de un edificio o un parque.

Con esta información podemos determinar de que tipo de objeto estamos tratando
y asignarle un valor concreto en la matriz de calles de cada escenario.

También nos valemos de esta información para filtrar la información.

Hasta ahora hemos optado por quedarnos solo con la información que queremos,
pero si algún día se añade un nuevo tipo de información que no tenemos habría
que añadirlo al filtrado de etiquetas.

También hay etiquetas que reconocemos y que no necesitamos, como por ejemplo,
los limites políticos de las ciudades.

\subsection*{Dibujar Calles}
%De coordenadas a casillas
OSM nos da la información de las calles como listas de puntos que hay que unir
con lineas rectas.

Esto plantea dos problemas.

Uno de ellos lo resolvemos pasando de coordenadas a casillas, como ya hemos
explicado en \hyperref[coordToCasilla]{\bf Coordenada a Casilla}

El otro problema es crear una linea recta mediando dos puntos.
Además hay que tener en cuenta el problema de las rectas en un plano hexagonal.

Para hallar los puntos de las rectas nos valemos de la ecuación de la recta
dados dos puntos, y a través de su pendiente podemos saber cual será el próximo
punto.

Para el problema del mapa hexagonal usamos dos técnicas, la primer es buscar el
siguiente punto de la recta pero con la mitad de distancia de una casilla, así
hacemos los cambios gradualmente y nos aseguramos la conexión del camino con
las casillas.
Pero esto no soluciona el problema de las diagonales, para esto usamos vectores
de direcciones para corregir el rumbo y hacerlo mas adecuado a la malla
hexagonal.

Con esto tenemos mas puntos de los necesarios para pintar una recta, por lo que
al pintarla, guardamos siempre la casilla anterior, y si es la misma, no
pintamos. 

Esto soluciona el problema de las \hyperref[Intersecciones]
{\bf intersecciones}.
\subsection*{Rellenar Figuras}
%Lineas poligonales cerradas y members
Existen tres figuras diferentes a la hora de dibujar los mapas.
Los puntos simples, las lineas rectas y las lineas polinomiales cerradas.

Las lineas polinomiales cerradas se componen de lineas rectas que a su vez son
una sucesión de puntos.

\subsubsection*{Lineas poligonales cerradas}
%los parques y contornos de edificios
Esto es un problema de geometría computacional. Hallar los puntos que encierra
una linea.

Esto es importante si queremos reflejar la extensión de un río o de un parque,
o cualquier otra superficie que ocupe mas de un punto.

Es un problema muy conocido en geometría computacional por lo que hay muchos
algoritmos sencillo que dada una lista de
puntos que describen un polígono te dicen si el punto esta dentro o no.

Por lo que una vez identificadas las lineas cerradas. El primer punto de la
lista, es igual al ultimo punto de la lista. Simplemente hay que aplicar el
algoritmo y rellenar las zonas con el valor adecuado.
\subsubsection*{Relaciones}
%rios, mares ....
Sin embargo existen otras figuras mas complejas, como las orillas de los rios,
o las costas. OSM también nos da esta información, pero no es tan sencillo de
interpretar ya que solo nos dice que es una orilla, y que pertenece a un rio en
concreto.
Pero dadas dos orillas del mismo río, como se cual es cual y en que dirección
hay que rellenar el agua. O peor aún, y si en nuestro mapa, solo tenemos una
orilla del río.

OSM ya provee este problema, y cuando pedimos la información de un lugar, no da
también información de los alrededores, y si en nuestra zona solo aparece una
orilla del río, OSM nos da la información también de la otra orilla.

De esta forma, podemos calcular el cauce del río aunque este fuera de nuestro
mapa, y pintar solo aquellas regiones que estén dentro del mismo.

Una vez mas la forma que tiene OSM de organizar los datos nos da la solución,
porque simplemente encadenando la información de las dos orillas del río nos da
la figura que envuelve a las dos orillas del río.

Para la Costa y otras formaciones de agua o figuras complejas es equivalente.
\subsection*{Intersecciones de Caminos} \label{Intersecciones}
Además del tipo de camino que estamos guardando en la matriz de calles del
escenario, podemos almacenar de una forma inteligente información sobre las
calles, como por ejemplo si una casilla en concreto forma parte de una
intersección de calles, sin tener que mirar las casillas adyacentes. La forma
de solucionar esto es simplemente dándoles por defecto una valor par a todos
los tipos de caminos, y si alguna vez un camino se cruza (siempre y cuando sea
de su mismo tipo) se guarda esta casilla con un valor impar.

De esta manera tan simple, podemos identificar y almacenar las calles que
conectan con otras calles.

\section*{Generador de KML}
Para general los archivos KML utilizamos
JAK\footnote{JAK Java API for KML :
\url{http://labs.micromata.de/display/jak/Home}}.
\subsection*{Múltiples Escenarios}
%Soporte para varios escenarios
El visor de KML puede recibir información de varios escenarios, ya que al estar
todo geolocalizado, no tengo problema de integrar múltiples
escenarios, salvo por el volumen de datos.
\subsection*{Secuencia de Tiempo}
%Soporte para la temporalidad de los eventos
Para podes simular la simulación fielmente necesito una marca de tiempo, para
ello tenemos que llevar un control del tiempo real en la simulación, 
%TODO enlace a clokagent
\subsection*{KmlPolygon}
%Agrupar poligonos por altura
Al igual que creamos una clase para tratar la información de OSM, creamos una
clase amigable para tratar los polígonos en KML.

Toda la información de la simulación la tenemos que representar por medio de
polígonos en el KML. La cual nos facilita la creación y la asignación de las
propiedades que queremos que tenga nuestro polígono.

Para ello contamos con la posición, la forma, la altura del polígono, el color,
y la transparencia.

Haciendo un buen uso de estas características podemos expresar mucha
información de una forma eficaz y elegante.
\subsubsection*{Bordes}
Tenemos dos problemas, las posiciones de los polígonos nos vienen dadas a
través de un única coordenada, pero nosotros para dibujar el polígono
necesitamos conocer los bordes.

Esto se hace simplemente con los \hyperref[incrementos]{\bf incrementos} y un
poco de trigonometría.

El otro problema que tenemos es mucho mas grande y es precisamente ese, el
tamaño.

La simulación produce mucha información que reflejar en un solo archivo. Por
cada casilla inundada son 7 coordenadas, si eso lo multiplicamos por las
casillas inundadas y por el numero de instantáneas y que todo eso va almacenado
en un fichero KML acabamos teniendo ficheros de tamaño muy considerable, que al
ser representados por un visor nos da un límite de información.

Para poder almacenar la mayor cantidad posible de datos, usamos la versión KMZ
de los archivos, (que no es mas que versiones comprimidas en zip de los
archivos KML) y además una agrupación de casillas inundadas al mismo nivel.

Esto quiere decir, que si tenemos un conjunto de casillas adyacentes que con el
mismo nivel en la inundación, estas casillas pasan a 1 único polígono y solo
tendríamos que almacenar el valor de su perímetro, no de todas las casillas que
lo contienen.

Con este sistema condensaremos mucha información debido a la naturaleza del
agua, a permanecer a un nivel determinado.

Para ello hacemos uso otra vez de conocimientos de geometría computacional y
del operador borde, en este caso, con el que podemos hallar el borde de
cualquier figura.

Para detectar los bordes y sobre todo escribirlos en el orden correcto,
utilizamos el operador borde (elimina los opuestos) y las listas de adyacentes.

Asumimos que la lista de adyacentes mas larga es el borde exterior
\subsubsection*{Color y Transparencia}
%decidimos usar hexagonos de distintos colores
Como ya comentamos antes, nos valemos del color para representar información de
manera intuitiva. Azul para el agua, Verde para personas a salvo ... etc.

KML permite asignarle color a las figuras de forma nativa, así que simplemente
creamos unos estilos predefinidos, y los asignamos a los polígonos.

El color se calcula para cada uno de los objetos, y es común para los objetos
equivalentes. 

Para el agua, si un polígono tiene la
misma altura de agua, todos tendrán el mismo color y transparencia por ser
equivalentes.

Para las personas igual, les asignamos colores (y una altura de 5 metros para
que sean fácilmente identificables) y ninguna transparencia.
Así tenemos que las personas que están en refugios tendrán el color verde, las
personas que se encuentren en peligro tendrán el color amarillo, y las personas
que se hallen atrapadas o muertas tendrán color gris.

Con este sencillo método podemos representar la información de manera muy
visual y expresiva.
\section*{Visor Bidimensional}
\subsection*{Múltiples escenarios}
\section*{Estadísticas}
Siguiendo la misma estrategia que los demás objetos que se actualizan
periódicamente, hemos diseñado un agente estadístico que se encarga de recoger
información de cada estado de la simulación.

Recogiendo la información deseada, en nuestro caso, el estado de las personas,
y el tiempo de la simulación, podemos hacer una evaluación estadística de la
evolución de la inundación, sabiendo cuales han sido las zonas donde mas
personas han perecido, o salvado y la hora en la que sucedió.
\subsection*{Múltiples Escenarios}
%Soporte para varios escenarios
Nuestra simulación puede tener mas de un escenario, por ello necesitamos
identificar de que escenario estamos recogiendo los datos, esto lo realizamos
simplemente añadiendo una columna con el identificador del escenario.
\subsection*{Ficheros CVS}
%Es lo mas comodo para las estadisticas
Los ficheros CSV\footnote{Valores Separados por Coma :
\url{http://es.wikipedia.org/wiki/CSV}} son muy fáciles de escribir y leer y la
forma mas simple de almacenar información. Por ello los hace ideales para
nuestro propósito de recoger una serie de estadísticas y guardarlas en un
fichero que sigue una forma estándar de almacenar los datos y que es reconocida
por la mayoría de hojas de cálculo y fácilmente se pueden generar gráficas a 
partir de estos ficheros.
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../dissim"
%%% End: