% Metodología e implementación

\chapter*{Implementación} \label{cap5}
\addcontentsline{toc}{chapter}{Implementación}

\pagenumbering{arabic}

\begin{flushright}
\begin{minipage}{7.85cm}
    {\em Blah blah blah.} \\  Alguien
\end{minipage}
\end{flushright}

\vspace*{5mm}

\section*{Metodología}
%Es un proyecto grande, que hay que organizarse, que usamos una
%metodologia agil, poniendonos metas a corto plazo y repartiendo la carga de
%trabajo
Al ser este un proyecto de tamaño considerable y ser también colaborativo es
necesario establecer una metodología para evitar el trabajo inútil y redundante.

Para organizar nuestro trabajo y poder mantener siempre cierto control sobre la
aplicación nos hemos servido tanto de herramientas, como de buenas prácticas.

Para comenzar y habiendo desarrollado nuestro proyecto en el marco del IV CUSL
\footnote{Concurso Universitario de
Software Libre:\url{http://www.concursosoftwarelibre.org/}} tuvimos que seguir
una política de divulgación de la información y unos plazos de entrega, también
pusieron a nuestra disposición una la forja
\footnote{Iris Libre: \url{https://forja.rediris.es/projects/cusl4-catastrof/}}
con la que pudimos agilizar y centralizar las labores de administración y
planificación del proyecto.

Además adoptamos una política de entrevistas frecuentes con los tutores para
así motivarnos y que nos aconsejaran sobre el mejor siguiente paso o en donde
deberíamos profundizar mas o seguir otras vías de investigación.

Por lo que teníamos un objetivo a corto plazo y herramienta para la
planificación gracias al  IV CUSL, y guía por parte de los tutores.

\subsection*{Metodologías Ágiles}
%Desarrollar pequeñas aplicaciones que sean funcionales y con un limite de
%tiempo, permite tener una version incremental del proyecto y facilita la
%planificación, la priorización de tareas y el reparto.

Una buena planificación no implica el éxito, pero por lo menos te asegura unos
resultados mínimos.

No hemos aplicado ninguna metodología en concreto, si no mas bien un conjunto
de técnicas y buenos métodos.

\subsubsection*{Reuniones de desarrollo}
Lo principal es la comunicación entre los desarrolladores, para ello decidimos
reunirnos y comentar las avances o principales problemas al menos dos veces a
la semana.

Las reuniones no tenían que ser en persona ni muy formales, podían realizarse a
través de mensajería instantánea ayudados con herramientas de pizarras
virtuales. De
esta forma siempre se tiene una idea muy cercana del desarrollo del proyecto sin
perder mucho tiempo.

Además mantiene un fuerte lazo entre los desarrolladores y les permite ayudarse
unos a otros, evitando así estancamientos o frustraciones con problemas
difíciles.
\subsubsection*{Reuniones con los tutores}
Al menos dos veces al mes, dependiendo del ritmo de trabajo y progresos. De
carácter informativo y orientativo.

Permite un crecimiento guiado y controlado del producto final, y un nivel de
acabado mayor al centrarnos solo en las partes realmente importantes de la
investigación y el desarrollo para los objetivos del proyecto.

\subsubsection*{Sistema incremental}
Lo principal era desarrollar una plataforma muy básica y sencilla donde se
pudieran llevar a cabo pruebas, y una vez completada, ir aumentando las
funcionalidades en forma de módulos o complementos que fueran implementando las
funcionalidades deseadas.

\subsubsection*{Reparto de tareas dinámico} %TODO revisar redacción
El reparto de tareas equitativo y ágil es vital para mantener una buena
relación entre los desarrolladores y el progreso del proyecto.

Por ello es importante identificar las tareas a realizar e ir asignándolas a
los desarrolladores de forma que ellos mismos puedan decidir como organizarse
pero siempre teniendo en cuenta unos plazos finales.

Pero el reparto no es estático, puesto que las tareas se pueden alargar o
acortar debido a una mala estimación inicial, por lo que las tareas se pueden
reasignar o subdividir para agilizar el desarrollo.

Al haber mas de un desarrollador en el proyecto hemos tendido un poco a la
especialización en las tareas, puesto que si a un desarrollador se ha estado
trabajando en una parte o se le da bien un determinado desarrollo, este
desarrollador tendrá prioridad y se le asignarán las tareas principales en las
que este mas cómodo.

Sin embargo, no se trata de dividir el proyecto en dos, puesto que siempre se
trata de que todos los desarrolladores estén implicados en todas las ramas
para mantener la cohesión en todo el proyecto.

\subsection*{Forja RedIris}
%La forja esta bien, te permite controlar las tareas abiertas y el tiempo que te
%tiras con ellas, tambien vale para repartirlas
RedIris\footnote{Forja Red Iris Libre:\url{https://forja.rediris.es/}} dispone
de una serie de
herramientas para el alojamiento y la gestión de proyectos de carácter
colaborativo y con vistas de crear una comunidad de desarrolladores.
Entre ellas las mas utilizadas:
\subsubsection*{Subversion}
%Esta bien, pero es muy limitao
sistema de control de versiones
SVN\footnote{http://es.wikipedia.org/wiki/Subversion}, permite llevar un
control sobre los cambios en el código y una copia siempre actualizada de
todos los cambios
\subsubsection*{Planificador de Tareas}
La forja también dispone de una sencilla aplicación de control de tareas.
que entre otras cosas,lo que permite es:
\begin{enumerate}
 \item Crear una tarea, con una breve descripción de la misma.
 \item Asignarlas a un desarrollador, y así poder repartir la carga de trabajo.
 \item Estimación del tiempo necesario, y así poder planificar otras tareas.
 \item Progreso de la tarea, para poder hacer un seguimiento del progreso de la
misma.
 \item Fecha limite de finalización, permite facilitar la planificación
\end{enumerate}
Con estos sencillos parámetros la herramienta incluso genera un diagrama de
GANTT
\footnote{Diagrama de
Gantt:\url{http://es.wikipedia.org/wiki/Diagrama_de_Gantt}} para ayudarte con
la planificación.

\subsection*{Blog}
%Es una buena idea, porque al escribir articulos sirve para pensar mas en lo que
%haces y darle visiblidad, tambien era un requisito para el concurso de software
%libre y sirve para historico y desarrollo  del proyecto.
El llevar al día un blog \footnote{Simulación de Catástrofes
:\url{http://pfc.mensab.com/}} con las actualizaciones y las direcciones
generales sobre el desarrollo proyecto es algo altamente recomendable si se
quiere que el proyecto cree una comunidad, puesto que es una manera muy cómoda y
eficaz de mantener a la comunidad informada de los cambios y el estado del
proyecto.

Además también tiene otras implicaciones mas sutiles, por ejemplo permite
reafirmar las decisiones de diseño o de desarrollo tomadas a lo largo de la
implementación, puesto que queda constancia de las decisiones tomadas y las
razones para llevarlas a cabo.
\subsubsection*{Git}
%Nueva forma de ver las cosas, muchos commits, cambios muy controlaos,
%posibilidad de hacer ramas y mantener siempre una rama estable.
Git\footnote{Git - Fast Version Control System : \url{http://git-scm.com/}} es
un sistema de control de versiones distribuido que cambia un poco la filosofía
de SVN.

En cada proyecto colaborativo hay muchos desarrolladores que necesitan hacer
muchos cambios, probar muchas alternativas de su código y sin embargo mantener
a todo el mundo informado y a su vez mantener una rama estable de desarrollo.
SVN tiene problemas al gestionar las diferentes ramas de desarrollo, sobre todo
al unirlas.

Git soluciona este problema al fomentar los commits pequeños y una herramienta
de merge mas eficiente, que facilita trabajar con ramas, así todas las ramas
que tengan puntos en común pueden ser agrupadas y mantenidas muy fácilmente.

Con su sistema de log y sus normas de estilo siempre se podrá tener un
seguimiento de todos los cambios muy bien documentados del código, y una rama
master siempre funcional con muchas ramas de desarrollo alternativo y de fácil
integración.

Por estas razones decidimos migrar la aplicación a de SVN en RedIris a GIT en
Gitorious\footnote{Hosting de proyectos en GIT :
\url{http://gitorious.org/}} sin ningún esfuerzo y con muchísimas ventajas.
%Ahora pasamos a nuestra implementación concreta.
\section*{Implementación del Escenario de Simulación}
\section*{Implementación de los Agentes en la Simulación}
\subsection*{Agente Creador}
\subsection*{Agente Reloj}
%la necesidad de determinar el tiempo
\subsection*{Agentes Entorno}
\subsection*{Agentes Entrada de Agua}
\subsection*{Agentes Peatón}
\subsubsection*{Actualización del estado}
%como determina el estado del peaton segun el entorno
\subsection*{Agentes Actualización}
\subsubsection*{Actualización entre entornos adyacentes}
%pasarse el aguita de unos a otros
\section*{Rejilla Hexagonal}
%Discretización del mundo real
\subsection*{Matriz de Altura}
Una matriz de short solo puede albergar un rango de alturas desde +-32,767, que
dependiendo de la precisión puede ser mas o menos altura
\subsection*{Matriz de Agua}
%Hay que saber cuanta agua tenemos pa moverla
\subsection*{Matriz de Calles}
%Las calles hay que guardarlas en algun lao
Cada entorno necesita un mapa de la ciudad propio.

Este mapa solo se calculará en el inicio y no cambiará durante la simulación.

Para mejorar el tamaño en memoria usamos una matriz de short del mismo tamaño
que el entorno.
\subsubsection*{Tipos de Calles}
%Especificación de OSM
Para saber en que tipo de calle nos encontramos nos ayudamos de la información
de OSM que viene categorizada en grupos. Por cada grupo le asignamos un rango
de valores, teniendo en cuenta el numero de subgrupos.

Estos valores vienen identificados por medio de constantes globales y funciones
estáticas que nos devuelven el tipo concreto o los valores padre.
\subsubsection*{Prioridad de la información}
En cada casilla solo podemos almacenar un valor, por lo que la forma de
rellenar la matriz sobreescribe el valor de la matriz si el nuevo valor es
mayor que el viejo. Así nos aseguramos que la información que consideramos mas
prioritaria (de mayor valor) permanezca en la matriz
\subsubsection*{Intersecciones}
A veces es útil sobre todo para las calles saber cuando nos encontramos en un
cruce, para ello cuando nos encontramos un valor igual al que nosotros queremos
inserta, incrementamos en una unidad el valor, haciéndola impar, de esta forma
detectamos las intersecciones.
\subsection*{Coronas}
%mantenimiento actualizado de la corona
\subsection*{Coordenada a Tile}
%conversion de una coordenada a un tile, necesidad de los incrementos %TODO
Nosotros hacemos una aproximación teniendo en cuenta que para distancias cortas
podemos obviar la curvatura de la corteza terrestre y a pelo hallamos la
diferencia en grados decimales y a tirar millas
\subsubsection*{Discretización}
%perdida de datos, caminos no conexos, indeterminacion de las posisciones
Errores de aproximación, puede dar la de al lado. jodiendo caminos y cosas así
\subsection*{Tile a Coordenada}
%conversion de un tile a una coordenada, tener en cuenta las lineas
%pares/impares
Es mas fácil que el anterior, y además es determinista puesto que devuelve
siempre el centro del tile.
\subsection*{Especialización: Flood Hexagonal Grid}
%cambios de la rejilla por desastre
\section*{Implementación de la Elevación del Terreno}
%Solucion particular
Usamos los servicios web para extraer las alturas, un bucle por cada casilla
\subsection*{Patrón Fachada} %TODO
%Para poder utilizar todos los servicios web de alturas que hagan falta
Tenemos una fachada para implementar los posibles distintos servicios webs,
tienen que implementar estas funciones, tralaraaaaaa
\subsection*{Cache de alturas}
%Para mejorar la latencia de datos
Los servidores webs suelen ser muy lentos, y el volumen de datos que
necesitamos para la simulación puede ser muy grande.

Obtener todos estos datos cada vez que necesitemos simular un escenario no es
viable.

La solución que nosotros implementamos es almacenar en local los datos para
utilizarlos en posteriores simulaciones o incluso para poder reutilizarlos en
otras simulaciones.

La reutilización de datos se hace por medio de una interpolación (la media de
las casillas adyacentes) de datos en el caso de que nuestra base de datos tenga
la información suficiente.

En nuestra implementación optamos por usar  SQLite\footnote{SQLite Home Page :
\url{www.sqlite.org/}} porque sencillez para la
implementación y por la sencillez de la base de datos en si, que permite poder
moverla de un ordenador a otro con un coste mínimo de instalación al ser un
único fichero el que contiene todos los datos.

El principal problema de SQLite es que no puede albergar muchos datos, pero en
nuestro caso esto se puede resolver creando mas ficheros, y de esta forma
abordamos la escalabilidad.

La base de datos solo contiene una única tabla
\begin{center}
\begin{tabular}{ | l | c | r | }
\hline
Clave & Tipo \\ \hline
Lat & double \\ \hline
Long & double \\ \hline
Elev & double \\ \hline
\end{tabular}
\end{center}


\subsubsection*{Patrón fachada}
%pos una fachada pa poder usar distintos drivers
El diseño de la interfaz para trabajar con servicios web ha sido realizado
teniendo en cuenta el patrón fachada para poder incorporar nuevos servicios web
de altura.

Gracias a este diseño añadir nuevos servicios webs solo tienen el coste de
implementar la clase que cumpla los métodos de la interfaz.
\section*{Open Street Maps}
OSM tiene un servicio web, que a través de mandarle un url correctamente
formada devuelve un fichero XML que contiene toda la información de OSM sobre
unas coordinadas determinadas.

La url se compone de una {\bf Dirección Base} + {\bf Coordenada Inferior
 derecha} + {\bf Coordenada Superior Izquierda} y devolverá un fichero con el
mismo nombre que la petición.
\subsection*{Parseando XML}
%Leer y obtener información
La información viene codificada en un fichero XML siguiendo el estándar de OSM.
Para poder extraer la información es necesario primero parsear el fichero.
Para ello utilizamos JAXB\footnote{Java Architecture for XML Binding :
\url{https://jaxb.dev.java.net/}} que es una librería para recorrer ficheros
XML. 

Mientras realizamos el recorrido del fichero, hay que identificar la
información de las etiquetas y almacenarla en nuestra estructura de datos para
poder utilizarla de una forma mas cómoda.

El diseño de las clases para almacenar la información de OSM es muy parecido a
la jerarquía de información que sigue OSM.

Tenemos la clase principal OsmMap, que contiene toda la información que nos da
OSM.

{\bf OsmWay} para la etiqueta way y {\bf OsmMember} para los caminos
compuestos, {\bf OsmRelation} para los rios y parques, y {\bf OsmNode} para los
puntos simples y puntos de interés. 

Para almacenar la información extra tenemos OsmTag.
\subsubsection*{Filtro de información}
%Quedarnos con la información útil
OsmTag contiene dos atributos principales, clave y valor. Nos valemos de estos
dos atributos para almacenar la información extra que nos ofrece OSM, como el
nombre de la calle, el tipo de calle, o si se trata de un edificio o un parque.

Con esta información podemos determinar de que tipo de objeto estamos tratando
y asignarle un valor concreto en la matriz de calles de cada escenario.

También nos valemos de esta información para filtrar la información.

Hasta ahora hemos optado por quedarnos solo con la información que queremos,
pero si algún día se añade un nuevo tipo de información que no tenemos habría
que añadirlo al filtrado de etiquetas.

También hay etiquetas que reconocemos y que no necesitamos, como por ejemplo,
los limites políticos de las ciudades.

\subsection*{Dibujar Calles}
%De coordenadas a tiles
El problema de una lista de puntos al mundo hexagonal, creamos aristas que son
ecuaciones de recta con los vértices y con chapuzas de dirección y de dar
saltitos mas cortos que el tile lo solucionamos
\subsection*{Rellenar Figuras}
%Lineas poligonales cerradas y members
Algunas figuras, como los parques vienen dadas por lineas cerradas, hay que
detectarlas (primero nodo == ultimo nodo) y rellenarlas.

\subsubsection*{Lineas poligonales cerradas}
%los parques y contornos de edificios
En geometría computacional hay un algoritmo sencillo que dada una lista de
puntos que describen un polígono te dicen si el punto esta dentro o no.
\subsubsection*{Relaciones}
%rios, mares ....
Hay polígonos que vienen descritos por mas de una linea poligonal y que no
están cerrados, tales como los ríos y los mares, el tema esta en concatenar
estas lineas en el mismo orden que te los da OSM y crear un polígono cerrado
con ellas, y funciona relativamente bien.
\section*{Generador de KML}
Necesitamos escribir en KML, y para ello contamos con unas librerías de XML y
JAK, que es una librería de KML para Java.
\subsection*{Múltiples Escenarios}
%Soporte para varios escenarios
Como todo esta geolocalizado, no tengo problema de integrar múltiples
escenarios, salvo por el volumen de datos.
\subsection*{Secuencia de Tiempo}
%Soporte para la temporalidad de los eventos
Para podes simular la simulación fielmente necesito una marca de tiempo, 
\subsubsection*{Sincronización}
%Hablar de la necesidad de un agente reloj.
Con la marca de tiempo no me tengo que preocupar de sincronizarlos porque ya me
vienen sincronizados gracias a agente reloj
\subsection*{KmlPolygon}
%Agrupar poligonos por altura
Necesito un objeto propio para convertir la información tal como me la da OSM
en listas de puntos, a algo que pueda interpretar KML, para ello me creo una
clase que hace de adaptador
\subsubsection*{Bordes}
Para detectar los bordes y sobre todo escribirlos en el orden correcto,
utilizamos el operador borde (elimina los opuestos) y las listas de adyacentes.

Asumimos que la lista de adyacentes mas larga es el borde exterior
\subsubsection*{Color}
%decidimos usar hexagonos de distintos colores
En vez de diferentes formas, le damos colores, azul para el agua, amarillo para
los peatones corriendo ...
\subsubsection*{Transparencia}
%para dar sensacion de profundidad
Es un buen recurso para darle profundidad a la simulación, parte de una
opacidad media y a medida que sea mas profundo pues mas opaco.

Como lo que cuenta es la altura del agua, no la acumulada en el terreno en
concreto, se coge como altura el valor del primer elemento de de lista de bordes
\section*{Visor Bidimensional}
\subsection*{Múltiples escenarios}
\section*{Estadísticas}
Pues ala, un updateable y a esnifar los escenarios, recogiendo estadísticas de
peatones
\subsection*{Múltiples Escenarios}
%Soporte para varios escenarios
Esnifamos de los escenarios poniendo la fecha y el identificador de escenario
\subsection*{Ficheros CVS}
%Es lo mas comodo para las estadisticas
La forma mas fácil y rápida de guardar extraer información.