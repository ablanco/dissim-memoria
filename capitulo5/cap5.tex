% Metodología e implementación

\chapter*{Implementación} \label{cap5}
\addcontentsline{toc}{chapter}{Implementación}

\pagenumbering{arabic}

\begin{flushright}
\begin{minipage}{7.85cm}
    {\em Blah blah blah.} \\  Alguien
\end{minipage}
\end{flushright}

\vspace*{5mm}

\section*{Metodología}
%Es un proyecto grande, que hay que organizarse, que usamos una
%metodologia agil, poniendonos metas a corto plazo y repartiendo la carga de
%trabajo
Al ser este un proyecto de tamaño considerable y ser también colaborativo es
necesario establecer una metodología para evitar el trabajo inútil.

Para organizar nuestro trabajo y poder mantener siempre cierto control sobre la
aplicación nos hemos servido de tanto de herramientas, como de buenas prácticas.

Para comenzar y habiendo desarrollado nuestro proyecto en el marco del IV
Concurso Universitario de Software
Libre\footnote{http://www.concursosoftwarelibre.org/} se nos puso a disposición
la una forja
\footnote{https://forja.rediris.es/projects/cusl4-catastrof/} donde pudimos
alojar los comienzos de nuestro proyecto.

Además adoptamos una política de entrevistas frecuentes con los tutores para
así motivarnos y que nos aconsejaran sobre el mejor siguiente paso o en donde
deberíamos profundizar mas o seguir otras vías de investigación.

\subsection*{Metodologías Ágiles}
%Desarrollar pequeñas aplicaciones que sean funcionales y con un limite de
%tiempo, permite tener una version incremental del proyecto y facilita la
%planificación, la priorización de tareas y el reparto.

Una buena planificación no implica el éxito, pero por lo menos te asegura unos
resultados mínimos.

No hemos aplicado ninguna metodología en concreto, si no mas bien un conjunto
de técnicas y buenos métodos.

\subsubsection*{Reuniones de desarrollo}
Lo principal es la comunicación entre los desarrolladores, para ello decidimos
reunirnos y comentar las avances o principales problemas al menos dos veces a
la semana.

Las reuniones no tenían que ser en persona ni muy formales, podían realizarse a
través de mensajería instantánea ayudados con herramientas de pizarras
virtuales. De
esta forma siempre se tiene una idea muy cercana del desarrollo del proyecto sin
perder mucho tiempo.

Además mantiene un fuerte lazo entre los desarrolladores y les permite ayudarse
unos a otros, evitando así estancamientos o frustraciones con problemas
difíciles.
\subsubsection*{Reuniones con los tutores}
Al menos dos veces al mes, dependiendo del ritmo de trabajo y progresos. De
carácter informativo y orientativo.

\subsubsection*{Sistema incremental}
Lo principal era desarrollar una plataforma muy básica y sencilla donde se
pudieran llevar a cabo pruebas, y una vez completara, ir aumentando las
funcionalidades en forma de módulos.

\subsubsection*{Reparto de tareas dinámico} %TODO revisar redacción
Identificar las funcionalidades que se quieren implementar e ir
desarrollándolas en función de su complejidad intentando
siempre el equilibrio en la carga de trabajo.

Hay tareas que son mas sencillas que otras y que requieren mas recursos de
formación e investigación que otras.

Se tiende a la especialización.

\subsection*{Forja RedIRIS}
%La forja esta bien, te permite controlar las tareas abiertas y el tiempo que te
%tiras con ellas, tambien vale para repartirlas
La Forja Red Iris\footnote{https://forja.rediris.es/} dispone de una serie de
herramientas para el alojamiento y la gestión de proyectos de carácter
colaborativo y con vistas de crear una comunidad de desarrolladores.

Gracias a contar con nuestra propia Forja
\footnote{https://forja.rediris.es/projects/cusl4-catastrof/} y con las
herramientas que nos proporciona, entre ellas las mas utilizadas 
\subsubsection*{Subversion}
%Esta bien, pero es muy limitao
sistema de control de versiones
SVN\footnote{http://es.wikipedia.org/wiki/Subversion}, permite llevar un
control sobre los cambios en el código y una copia siempre actualizada de
todos los cambios
\subsubsection*{Planificador de Tareas}
La forja también dispone de una sencilla aplicación de control de tareas.
que entre otras cosas,lo que permite es:
\begin{enumerate}
 \item Crear una tarea, con una breve descripción de la misma.
 \item Asignarlas a un desarrollador, y así poder repartir la carga de trabajo.
 \item Estimación del tiempo necesario, y así poder planificar otras tareas.
 \item Progreso de la tarea, para poder hacer un seguimiento del progreso de la
misma.
 \item Fecha limite de finalización, permite facilitar la planificación
\end{enumerate}
Con estos sencillos parámetros la herramienta incluso genera un diagrama de
GANTT
\footnote{Diagrama de
Gantt:\url{http://es.wikipedia.org/wiki/Diagrama_de_Gantt}} para ayudarte con
la planificación.

\subsection*{Blog}
%Es una buena idea, porque al escribir articulos sirve para pensar mas en lo que
%haces y darle visiblidad, tambien era un requisito para el concurso de software
%libre y sirve para historico y desarrollo  del proyecto.
El llevar al día un blog \footnote{Simulación de Catástrofes
:\url{http://pfc.mensab.com/}} con las actualizaciones y las direcciones
generales sobre el desarrollo proyecto es algo altamente recomendable si se
quiere que el proyecto cree una comunidad, puesto que es una manera muy cómoda y
eficaz de mantener a la comunidad informada de los cambios y el estado del
proyecto.

Además también tiene otras implicaciones mas sutiles, por ejemplo permite
reafirmar las decisiones de diseño o de desarrollo tomadas a lo largo de la
implementación, puesto que queda constancia de las decisiones tomadas y las
razones para llevarlas a cabo.
\subsubsection*{Git}
%Nueva forma de ver las cosas, muchos commits, cambios muy controlaos,
%posibilidad de hacer ramas y mantener siempre una rama estable.

Git es un sistema de control de versiones distribuido que mola mazo %TODO

%Ahora pasamos a nuestra implementación concreta.
\section*{Implementación del Escenario de Simulación}
\section*{Implementación de los Agentes en la Simulación}
\subsection*{Agente Creador}
\subsection*{Agente Reloj}
%la necesidad de determinar el tiempo
\subsection*{Agentes Entorno}
\subsection*{Agentes Entrada de Agua}
\subsection*{Agentes Peatón}
\subsubsection*{Actualización del estado}
%como determina el estado del peaton segun el entorno
\subsection*{Agentes Actualización}
\subsubsection*{Actualización entre entornos adyacentes}
%pasarse el aguita de unos a otros
\section*{Rejilla Hexagonal}
%Discretización del mundo real
\subsection*{Matriz de Altura}
Una matriz de short solo puede albergar un rango de alturas desde +-32,767, que
dependiendo de la precisión puede ser mas o menos altura
\subsection*{Matriz de Agua}
%Hay que saber cuanta agua tenemos pa moverla
\subsection*{Matriz de Calles}
%Las calles hay que guardarlas en algun lao
Cada entorno necesita un mapa de la ciudad propio.

Este mapa solo se calculará en el inicio y no cambiará durante la simulación.

Para mejorar el tamaño en memoria usamos una matriz de short del mismo tamaño
que el entorno.
\subsubsection*{Tipos de Calles}
%Especificación de OSM
Para saber en que tipo de calle nos encontramos nos ayudamos de la información
de OSM que viene categorizada en grupos. Por cada grupo le asignamos un rango
de valores, teniendo en cuenta el numero de subgrupos.

Estos valores vienen identificados por medio de constantes globales y funciones
estáticas que nos devuelven el tipo concreto o los valores padre.
\subsubsection*{Prioridad de la información}
En cada casilla solo podemos almacenar un valor, por lo que la forma de
rellenar la matriz sobreescribe el valor de la matriz si el nuevo valor es
mayor que el viejo. Así nos aseguramos que la información que consideramos mas
prioritaria (de mayor valor) permanezca en la matriz
\subsubsection*{Intersecciones}
A veces es útil sobre todo para las calles saber cuando nos encontramos en un
cruce, para ello cuando nos encontramos un valor igual al que nosotros queremos
inserta, incrementamos en una unidad el valor, haciéndola impar, de esta forma
detectamos las intersecciones.
\subsection*{Coronas}
%mantenimiento actualizado de la corona
\subsection*{Coordenada a Tile}
%conversion de una coordenada a un tile, necesidad de los incrementos %TODO
Nosotros hacemos una aproximación teniendo en cuenta que para distancias cortas
podemos obviar la curvatura de la corteza terrestre y a pelo hallamos la
diferencia en grados decimales y a tirar millas
\subsubsection*{Discretización}
%perdida de datos, caminos no conexos, indeterminacion de las posisciones
Errores de aproximación, puede dar la de al lado. jodiendo caminos y cosas así
\subsection*{Tile a Coordenada}
%conversion de un tile a una coordenada, tener en cuenta las lineas
%pares/impares
Es mas fácil que el anterior, y además es determinista puesto que devuelve
siempre el centro del tile.
\subsection*{Especialización: Flood Hexagonal Grid}
%cambios de la rejilla por desastre
\section*{Implementación de la Elevación del Terreno}
%Solucion particular
Usamos los servicios web para extraer las alturas, un bucle por cada casilla
\subsection*{Patrón Fachada} %TODO
%Para poder utilizar todos los servicios web de alturas que hagan falta
Tenemos una fachada para implementar los posibles distintos servicios webs,
tienen que implementar estas funciones, tralaraaaaaa
\subsection*{Cache de alturas}
%Para mejorar la latencia de datos
Los servidores webs suelen ser muy lentos, para mejorar su respuesta utilizamos
una base de datos, además podemos hacer interpolación de datos en el caso de
que nuestra base de datos tenga la información suficiente.

Usamos sqlLite porque es un fichero y listo.

La consulta sql puede devolver mas de un dato, hacemos la media
\subsubsection*{Patrón fachada}
%pos una fachada pa poder usar distintos drivers
No nos cerramos a una sola base de datos, le enchufamos el driver y listo
\section*{Open Street Maps}
OSM nos da los datos como strings, pero ahora tenemos que tratarlos y
convertirlos a shorts.
\subsection*{Parseando XML}
%Leer y obtener información
La información viene codificada en un fichero xml, hay que parsearlo y después
recorrerlo para extraer toda la información, según la API de OSM. Clases
estáticas y guardamos el fichero en un directorio temporal.
\subsubsection*{Filtro de información}
%Quedarnos con la información útil
La etiqueta tag, nos vale para hacer filtros, y discriminar cierta información
que sabemos que no nos interesa, o para obtener cierta información
característica que nos interesa, por ejemplo el nombre de la calle, el tipo de
vía ...
\subsection*{Dibujar Calles}
%De coordenadas a tiles
El problema de una lista de puntos al mundo hexagonal, creamos aristas que son
ecuaciones de recta con los vértices y con chapuzas de dirección y de dar
saltitos mas cortos que el tile lo solucionamos
\subsection*{Rellenar Figuras}
%Lineas poligonales cerradas y members
Algunas figuras, como los parques vienen dadas por lineas cerradas, hay que
detectarlas (primero nodo == ultimo nodo) y rellenarlas.

\subsubsection*{Lineas poligonales cerradas}
%los parques y contornos de edificios
En geometría computacional hay un algoritmo sencillo que dada una lista de
puntos que describen un polígono te dicen si el punto esta dentro o no.
\subsubsection*{Relaciones}
%rios, mares ....
Hay polígonos que vienen descritos por mas de una linea poligonal y que no
están cerrados, tales como los ríos y los mares, el tema esta en concatenar
estas lineas en el mismo orden que te los da OSM y crear un polígono cerrado
con ellas, y funciona relativamente bien.
\section*{Generador de KML}
Necesitamos escribir en KML, y para ello contamos con unas librerías de XML y
JAK, que es una librería de KML para Java.
\subsection*{Múltiples Escenarios}
%Soporte para varios escenarios
Como todo esta geolocalizado, no tengo problema de integrar múltiples
escenarios, salvo por el volumen de datos.
\subsection*{Secuencia de Tiempo}
%Soporte para la temporalidad de los eventos
Para podes simular la simulación fielmente necesito una marca de tiempo, 
\subsubsection*{Sincronización}
%Hablar de la necesidad de un agente reloj.
Con la marca de tiempo no me tengo que preocupar de sincronizarlos porque ya me
vienen sincronizados gracias a agente reloj
\subsection*{KmlPolygon}
%Agrupar poligonos por altura
Necesito un objeto propio para convertir la información tal como me la da OSM
en listas de puntos, a algo que pueda interpretar KML, para ello me creo una
clase que hace de adaptador
\subsubsection*{Bordes}
Para detectar los bordes y sobre todo escribirlos en el orden correcto,
utilizamos el operador borde (elimina los opuestos) y las listas de adyacentes.

Asumimos que la lista de adyacentes mas larga es el borde exterior
\subsubsection*{Color}
%decidimos usar hexagonos de distintos colores
En vez de diferentes formas, le damos colores, azul para el agua, amarillo para
los peatones corriendo ...
\subsubsection*{Transparencia}
%para dar sensacion de profundidad
Es un buen recurso para darle profundidad a la simulación, parte de una
opacidad media y a medida que sea mas profundo pues mas opaco.

Como lo que cuenta es la altura del agua, no la acumulada en el terreno en
concreto, se coge como altura el valor del primer elemento de de lista de bordes
\section*{Visor Bidimensional}
\subsection*{Múltiples escenarios}
\section*{Estadísticas}
Pues ala, un updateable y a esnifar los escenarios, recogiendo estadísticas de
peatones
\subsection*{Múltiples Escenarios}
%Soporte para varios escenarios
Esnifamos de los escenarios poniendo la fecha y el identificador de escenario
\subsection*{Ficheros CVS}
%Es lo mas comodo para las estadisticas
La forma mas fácil y rápida de guardar extraer información.