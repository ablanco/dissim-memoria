% Metodología e implementación

\chapter*{Implementación} \label{cap5}
\addcontentsline{toc}{chapter}{Implementación}

\begin{flushright}
\begin{minipage}{7.85cm}
    {\em Si necesitas más de tres niveles de indentación estás jodido, y
    deberías arreglar tu programa.} \\  Linus Torvalds
\end{minipage}
\end{flushright}

\vspace*{5mm}

\section*{Metodología}

Al ser este un proyecto de tamaño considerable, y al realizarse en grupo, es
necesario establecer una metodología para evitar el trabajo inútil o redundante.

Para organizar nuestro trabajo, y poder mantener siempre cierto control sobre la
evolución de la aplicación, nos hemos servido tanto de herramientas como de
algunas buenas prácticas.

Habiendo desarrollado nuestro proyecto en el marco del IV CUSL\footnote{Concurso
Universitario de Software Libre: \url{http://www.concursosoftwarelibre.org}}
hemos seguido una política de divulgación de la información y unos plazos de
entrega. Desde la organización del concurso pusieron a nuestra disposición una
forja, en concreto la forja
IRIS-Libre\footnote{\url{https://forja.rediris.es/projects/cusl4-catastrof/}},
gracias a la que pudimos agilizar y centralizar las labores de administración y
planificación del proyecto.

Además adoptamos una política de entrevistas frecuentes con los tutores para
así motivarnos y que nos aconsejaran sobre el mejor paso a seguir, o en dónde
deberíamos profundizar más, o cuándo seguir otras vías de investigación.

De esta manera teníamos objetivos a corto plazo, herramientas para la
planificación gracias al IV CUSL, y guía por parte de los tutores.

\subsection*{Metodologías Ágiles}

Una buena planificación no implica el éxito, pero por lo menos te asegura unos
resultados mínimos.

No hemos aplicado ninguna metodología en concreto, si no un conjunto de técnicas
y buenos métodos. Creemos en una metodología de desarrollo ágil.

\subsubsection*{Reuniones de Desarrollo}

Lo principal es la comunicación entre los desarrolladores, para ello decidimos
reunirnos y comentar las avances o principales problemas al menos dos veces a
la semana.

Las reuniones no tenían por qué ser en persona, ni muy formales, podían
realizarse a través de mensajería instantánea, ayudados con herramientas de
pizarras virtuales. De esta forma siempre se tiene una idea muy cercana del
desarrollo del proyecto sin perder mucho tiempo.

Además mantiene un fuerte lazo entre los desarrolladores y les permite ayudarse
unos a otros, evitando así estancamientos o frustraciones con problemas
difíciles.

\subsubsection*{Reuniones con los Tutores}

Nos reuníamos con nuestros tutores al menos dos veces al mes, dependiendo del
ritmo de trabajo y progresos. Estas reuniones eran de carácter informativo y
orientativo.

Las reuniones permiten un crecimiento guiado y controlado del producto final, y
un nivel de acabado mayor al centrarnos solo en las partes realmente importantes
de la investigación y el desarrollo para los objetivos del proyecto.

\subsubsection*{Sistema Incremental}

Lo principal era desarrollar una plataforma muy básica y sencilla donde se
pudieran llevar a cabo pruebas, y una vez completada, ir aumentando las
prestaciones en forma de módulos o complementos que fueran implementando las
funcionalidades deseadas.

Seguimos pues un modelo iterativo de desarrollo del software, que es el ciclo
de vida del software que probablemente mejor se adapte a metodologías ágiles.

% TODO esquema del ciclo de vida iterativo

\subsubsection*{Reparto de Tareas Dinámico}

El reparto de tareas equitativo y ágil es vital para mantener una buena
relación entre los desarrolladores, y para el adecuado progreso del proyecto.

Por ello es importante identificar las tareas a realizar e ir asignándolas a
los desarrolladores, de forma que ellos mismos puedan decidir cómo organizarse,
pero siempre teniendo en cuenta unos plazos finales.

El reparto no siempre es estático, puesto que las tareas se pueden alargar o
acortar debido a una mala estimación inicial, incluso a veces se pueden
reasignar o subdividir para agilizar el desarrollo.

Al haber más de un desarrollador en el proyecto hemos tendido un poco a la
especialización en las tareas. Si un desarrollador ha estado trabajando en una
parte, o tiene experiencia y aptitudes para determinado aspecto del desarrollo,
tendrá prioridad a la hora de asignar las tareas relacionadas.

Sin embargo, no se trata de dividir el proyecto en dos, puesto que siempre se
intenta que todos los desarrolladores estén implicados en todas las ramas.
Después de todo el objetivo final del proyecto es aprender y ampliar
conocimientos en todas las áreas que éste toca.

\subsection*{Forja IRIS-Libre}

RedIRIS proporciona un servicio de forja bajo el nombre de
IRIS-Libre\footnote{\url{https://forja.rediris.es/}}. Esta forja proporciona
alojamiento y herramientas a proyectos de Software Libre, y está asociada al
CUSL, dando alojamiento a los proyectos participantes.

\begin{figure}[H]
 \centering
 \includegraphics[width=30mm]{figuras/cap5/iris_libre.png}
 \caption{Logo de IRIS-Libre}
\end{figure}

Entre las herramientas para el alojamiento y la gestión de proyectos de carácter
colaborativo, y con vistas de crear una comunidad de desarrolladores, que
proporciona encontramos:

\subsubsection*{Subversion}

Como sistema de control de versiones la forja proporciona
SVN\footnote{\url{http://subversion.tigris.org/}}, este sistema permite llevar
un control sobre los cambios en el código, y obtener siempre una copia
actualizada con la última versión.

\begin{figure}[H]
 \centering
 \includegraphics[width=80mm]{figuras/cap5/svn.png}
 \caption{Logo de Subversion}
\end{figure}

Este tipo de software es imprescindible cuando se trabaja en grupo, pues
facilita la colaboración y permite mantener un orden en el desarrollo.

\subsubsection*{Planificador de Tareas}

La forja también dispone de una sencilla aplicación de control de tareas, que,
entre otras cosas, lo que permite es:

\begin{enumerate}
 \item Crear una tarea, con una breve descripción de la misma.
 \item Asignarlas a un desarrollador, y así poder repartir la carga de trabajo.
 \item Estimación del tiempo necesario, para poder planificar otras tareas.
 \item Progreso de la tarea, para poder hacer un seguimiento del progreso de la
 misma.
 \item Fecha límite de finalización.
\end{enumerate}

Con estos sencillos parámetros la herramienta incluso genera un diagrama de
Gantt para ayudarte con la planificación.

% TODO incluir dicho diagrama

\subsection*{Blog}

La decisión de comenzar un blog para registrar la evolución del proyecto viene
motivada por el CUSL, que lo exige como requisito de los proyectos
participantes.

El llevar al día un blog\footnote{Simulación de Catástrofes:
\url{http://pfc.mensab.com/}}, con las actualizaciones y las direcciones
generales de desarrollo del proyecto, es algo altamente recomendable si se
quiere que el proyecto cree una comunidad. Es una manera muy cómoda y eficaz de
mantener a la comunidad informada de los cambios y el estado del proyecto.

Además también tiene otras consecuencias más sutiles; por ejemplo, permite
reafirmar las decisiones de diseño o de desarrollo tomadas a lo largo de la
implementación, puesto que queda constancia de las decisiones tomadas y las
razones para llevarlas a cabo.

\subsection*{Git}

Git\footnote{Git - Fast Version Control System: \url{http://git-scm.com/}} es
un sistema de control de versiones distribuido con filosofía distinta a la de
SVN, que es centralizado.

\begin{figure}[H]
 \centering
 \includegraphics[width=40mm]{figuras/cap5/git.png}
 \caption{Logo de Git}
\end{figure}

En cada proyecto colaborativo hay muchos desarrolladores que necesitan hacer
muchos cambios, probar muchas alternativas de su código y sin embargo mantener
a todo el mundo informado y a su vez mantener una rama estable de desarrollo.
SVN no es demasiado eficiente a la hora de gestionar diferentes ramas de
desarrollo, ni al crearlas ni al unirlas.

Git soluciona este problema al fomentar los {\em commits} pequeños y una
herramienta de {\em merge} más eficiente, lo que facilita trabajar con ramas y
mantenerlas muy fácilmente. El trabajo con diferentes ramas de desarrollo y
una rama {\em master} siempre funcional, de fácil integración entre sí, facilita
el desarrollo considerablemente. Git fomenta este estilo de desarrollo.

Con su sistema de log y sus normas de estilo mejora el seguimiento de todos los
cambios, muy bien documentados, del código.

Por estas razones decidimos migrar la aplicación de SVN a Git cuando terminó el
CUSL. Esta migración nos obligó a buscar una nueva forja que nos proporcionara
este avanzado sistema de control de versiones. La elegida fue
Gitorious\footnote{\url{http://gitorious.org/}}, forja libre para proyectos
libres.

\begin{figure}[H]
 \centering
 \includegraphics[width=40mm]{figuras/cap5/gitorious.png}
 \caption{Logo de Gitorious}
\end{figure}

\section*{Escenario de Simulación}

El escenario de simulación es la manera que tenemos de decirle a nuestro
simulador qué es lo que queremos simular precisamente. Dado que el simulador es
versátil y tiene capacidad de simular, en principio, cualquier lugar, hay que
definir una serie de parámetros de entrada.

En un escenario hemos de especificar cuál es el área con la que se va a
trabajar, cuáles son las entradas de agua y qué agentes humanos intervienen.
Aparte se definen también algunos parámetros técnicos como pueden ser los datos
de conexión a la base de datos de alturas.

Entrando en detalles los elementos de los que consta un escenario son:

\begin{description}
 \item[Nombre y descripción] Los escenarios se nombran para poder
identificarlos con facilidad, este nombre y descripción se muestra también en
los resultados de la simulación.
 \item[Fecha y hora] También se define la fecha y hora del comienzo de la
simulación, lo que permite localizar en el tiempo cada momento de la simulación.
 \item[Resolución temporal] Es necesario definir el tiempo transcurrido entre
dos estados de la simulación, tanto el tiempo simulado (en minutos) que
transcurre, como el tiempo de ejecución (en milisegundos) que se le concede a
la máquina -o máquinas- para simular un paso.
 \item[Área de simulación] El área viene definida por dos coordenadas
geográficas, la coordenada noroeste y la sureste del rectángulo -en realidad
no es un rectángulo si tenemos en cuenta la curvatura terrestre- que definen si
tomamos como diagonal el segmento que las une.
 \item[Resolución espacial] Uno de los parámetros más importantes que hay que
definir es la resolución espacial, tanto superficial como en altura. Hay que
especificar el tamaño de los hexágonos, lo que se hace a través del diámetro de
la circunferencia circunscrita en ellos -los hexágonos son regulares-. También
hay que definir la resolución espacial en altura, es decir, cómo se discretiza
la altura del terreno y del agua; se define como \begin{math}^1/_p\end{math}
metros de precisión donde {\em p} es el parámetro que aparece en el escenario.
 \item[Agentes Entorno] El número de agentes Entorno que se encargaran de
simular el escenario, el número adecuado depende de la cantidad de núcleos o
procesadores del que disponga la máquina donde se lleve a cabo la simulación.
 \item[Base de datos de alturas] En el escenario se incluyen también los datos
necesarios para realizar la conexión a la base de datos donde se almacenan la
elevación del terreno. Estos datos se obtienen de internet, pero se almacenan
localmente para agilizar simulaciones sucesivas en el mismo área.
 \item[Entradas de agua] A la hora de simular una inundación es básico simular
dónde y cuánta agua está entrando al sistema. Dichos datos se encuentran en el
escenario.
 \item[Peatones] La posición y características de los peatones, tales como su
distancia de visión, velocidad y objetivos -refugios que conocen de antemano-.
 \item[Frecuencia de actualización de resultados] Cada cuánto tiempo deben los
agentes Entorno enviar el estado de la simulación a los agentes encargados de
mostrar los resultados, así se define la finura de los resultados obtenidos.
\end{description}

Hay que destacar que los datos definidos en el escenario son los datos
iniciales de la simulación, y que muchos se traducen a agentes, como por
ejemplos las entradas de agua o las personas. Esto permite que en caliente se
puedan añadir, por ejemplo, nuevas fuentes de agua a la simulación, pues se
puede añadir agentes nuevos a una simulación en marcha.

\subsection*{Ejemplo de Escenario}

\lstinputlisting[caption=Escenario de ejemplo]{capitulo5/Ejemplo.scen}

Como se puede ver en el listado el formato de los ficheros escenario es {\em
clave=valor}, y para escribir un array -que son anidables, como se puede ver
también en el ejemplo- {\em clave=[elem,elem,elem...]}.

Lo primero que aparece es el {\em type}, es decir, el tipo de escenario del que
se trata. El valor es el nombre de la clase que hay que instanciar -que debe
heredar de {\em util.Scenario}-, por ahora sólo está implementado el caso de la
inundación, pero el escenario está preparado para múltiples tipos de desastres.

Es importante destacar que el orden en el que aparecen los elementos del
escenario en el fichero es irrelevante, cualquier orden es válido siempre que
aparezcan los elementos mínimos.

A continuación en el ejemplo aparecen el nombre ({\em name}), descripción ({\em
description}), fecha de inicio de la simulación ({\em date}) y hora inicial
({\em hour}).

Los dos siguientes elementos, {\em tick} y {\em realTick}, representan el
tiempo asignado a cada paso de la simulación. El primero se mide en
milisegundos y representa el tiempo de computación, es el que transcurre en
nuestro mundo; y el segundo se mide en minutos y representa cuanto tiempo ha
pasado dentro de la simulación.

{\em NW} y {\em SE} son dos arrays con las coordenadas geográficas de las dos
esquinas del área de simulación. Al igual que el resto de coordenadas que
aparecen en el escenario se escriben con el formato {\em [latitud,longitud]}.
{\em NW} hace referencia a la esquina noroeste, mientras que {\em SE}
referencia a la sureste.

{\em tileSize} corresponde al tamaño de los hexágonos, en metros, mientras que
{\em precision} define la resolución espacial en altura, en
\begin{math}^1/_{precision}\end{math} metros.

Seguido aparece el número de agentes {\bf Entorno}, con la clave {\em numEnvs}.
{\em randomTerrain} es un valor booleano que define si los entornos van a
utilizar datos reales de alturas, o van a generar terrenos aleatorios. Los dos
posibles valores que puede tomar son {\em True} y {\em False}, significando el
primero que el terreno simulado va a ser aleatorio.

A continuación vienen los datos necesarios para la conexión con la base de
datos de alturas. Todos comienzan por {\em DB}. {\em DBServer} es la url, ip,
nombre de fichero, etc, del servidor de base de datos. En este caso se trata de
un servidor que se encuentra en la misma máquina, y al que se accede por red
-de ahí las {\em //}-. {\em DBPort} es el puerto a usar para la conexión. {\em
DBUser} es el usuario con el que identificarse, y {\em DBPass} es la contraseña
en claro a utilizar. {\em DBDriver} especifica qué tipo de servidor se está
utilizando, en este caso se utiliza MySQL\footnote{\url{http://www.mysql.com/}}.
{\em DBDb} es el nombre de la base de datos donde se encuentra la tabla
{\bf Elevations}, dicha tabla está descrita en la sección donde se trata la
obtención de datos de alturas.

No todos los elementos {\em DB} son imprescindibles. Por ejemplo, si se utiliza
el servidor de base de datos de fichero
SQLite\footnote{\url{http://www.sqlite.org/}} no es necesario definir más que
{\em DBServer} y {\em DBDriver}.

Cada línea con la clave {\em waterSource} representa una entrada de agua
diferente al sistema, todas las entradas definidas en el fichero del escenario
se activan nada más comenzar la simulación. Para añadir fuentes de agua que
aparecen un tiempo después del comienzo de la simulación hay que añadir agentes
{\bf Entrada de Agua} en caliente. El array contiene los siguientes datos:
latitud, longitud y cantidad de agua que entra en cada tick medida en unidades
de altura de la simulación. El orden en que aparecen estos elementos es fijo.

Al igual que con las entradas de agua, puede haber múltiples líneas con la clave
{\em person}. Representan a agentes {\bf Peatón} en la simulación. Los
parámetros del array son, en orden, los siguientes: latitud, longitud,
distancia de visión en hexágonos, velocidad en hexágonos, número de clones y un
array de objetivos -con múltiples pares latitud y longitud, aunque en este caso
sólo hay un objetivo-. Todos estos parámetros serán discutidos en la sección de
los agentes {\bf Peatón}.

{\em updateTimeKML} y {\em updateTimeVisor} se miden ambos en milisegundos, y
hacen referencia al tiempo que transcurre entre que los agentes {\bf Entorno}
envían actualizaciones a los generadores de KML y a los visores respectivamente.

\subsection*{Generación de Escenarios}

Aunque es perfectamente posible escribir un fichero escenario con un editor de
textos, resulta más sencillo utilizar el script de lanzamiento de la simulación
para generar uno en un modo interactivo. Dicho modo se explica en detalle en la
sección dedicada al script de lanzamiento.

\section*{Agentes}

En esta sección se explicarán uno a uno todos los agentes que intervienen en la
simulación, y cómo se han implementado. Todos los agentes se encuentran en el
paquete, o en subpaquetes de éste, {\em agents}.

% TODO Diagrama de agentes y comportamientos en horizontal

% TODO Programación de agentes con JADE?

\subsection*{Agente Creador}

La misión de este agente es la de crear al resto de agentes y lanzar la
simulación.

\begin{figure}[H]
 \centering
 \includegraphics[width=100mm]{figuras/cap5/ag_creator.png}
 \caption{Agente Creador y sus comportamientos}
\end{figure}

Su ejecución consta de tres fases. En la primera procesa el fichero escenario y
crea a los agentes {\em Entorno}, a través del comportamiento {\em
CreateAgentBehav}, que es el comportamiento utilizado para crear agentes y que
se encuentra en el paquete {\em behaviours}. El agente se queda esperando a que
los agentes {\bf Entorno} terminen de inicializarse, para ello utiliza el
comportamiento {\em WaitForReadyBehav}, del mismo paquete.

Una vez listos, el agente {\bf Creador} pasa a la segunda fase en donde crea al
resto de agentes: {\bf Entradas de Agua}, {\bf Peatones}, etc, todo según se
describa en el escenario. Es necesario esperar a que se inicialicen los
entornos, dado que es un proceso lento (han de obtener las alturas y las
calles) y el resto de agentes los necesitan preparados pues les preguntan cosas.
Por último crea al agente {\bf Reloj} dando comienzo así a la simulación.

En la tercera y última fase, el {\bf Creador} se queda inactivo a la espera de
mensajes que soliciten el objeto escenario, enviándoselo a los agentes que
manden dichos mensajes. Esta actividad la realiza a través del comportamiento
{\em SendScenarioBehav}.

Este último comportamiento actúa como servidor del objeto escenario, y se
implementa mediante un {\em CyclicBehaviour} de JADE.

\subsection*{Agente Reloj}
%la necesidad de determinar el tiempo
\subsection*{Agentes Entorno}
\subsection*{Agentes Entrada de Agua}
\subsubsection{El Movimiento del Agua}
%Esto ya forma parte de las explicaciones
Por lo tanto, vistas nuestras limitaciones y sobre todo nuestra intención de un
modelo simple, a la hora de simular la propagación de una cierta cantidad de
agua sobre un terreno nos apoyamos en la iteración sobre el bucle del
comportamiento del agua, asumimos (que ya es mucho asumir), que en cada paso del
bucle, el agua se mueve hacia cuadrado adyacente que tenga una altura menor que
la propia, por lo tanto, el agua se moverá a tantas casillas adyacentes como
vueltas de el bucle. Así es de una manera muy simple, como simulamos la
propagación, dándole un valor de repetición a ese bucle.

Para el cálculo de este parámetro ............ bla bla bla %TODO

De esta forma tan simple, podemos controlar de una cierta manera razonable la
velocidad de propagación que tendrá el agua.

\subsection*{Agentes Peatón}
\subsubsection*{Actualización del estado}
%como determina el estado del peaton segun el entorno
\subsection*{Agentes Actualización}
\subsubsection*{Actualización entre entornos adyacentes}
%pasarse el aguita de unos a otros
\section*{Rejilla Hexagonal}
%Discretización del mundo real
Sobre la rejilla es donde se van a realizar todos los cálculos de la
simulación, por lo tanto dispone de todos los métodos para manipular
y obtener información contenida en ella.

También contiene funciones básicas como dado un punto obtener todos sus
adyacentes, o devolver todas las casillas que se puedan ver desde una posición
y un rango de visión.

También dispone de métodos para obtener caminos utilizando la adyacencia
hexagonal.
\subsection*{Matriz de Altura}
Una matriz de short solo puede albergar un rango de alturas desde +-32,767, que
dependiendo de la precisión puede ser mas o menos altura
\subsection*{Matriz de Agua}
%Hay que saber cuanta agua tenemos pa moverla
Al igual que la matriz de alturas se trara de una matriz de short del mimo
tamaño que la del entorno, pero esta contiene solo información de la cantidad
de agua que hay en esta casilla.

Este valor nunca podrá ser menor que cero.

Sumando las matrices de alturas y agua se obtiene la altura total del terreno.

Esta matriz es especifica de las inundaciones, puesto que para otras
catástrofes no es necesaria.
\subsection*{Matriz de Calles}
%Las calles hay que guardarlas en algun lao
Cada entorno necesita un mapa de la ciudad propio.

Este mapa solo se calculará en el inicio y no cambiará durante la simulación.

Para mejorar el tamaño en memoria usamos una matriz de short del mismo tamaño
que el entorno.
\subsubsection*{Tipos de Calles}
%Especificación de OSM
Para saber en que tipo de calle nos encontramos nos ayudamos de la información
de OSM que viene categorizada en grupos. Por cada grupo le asignamos un rango
de valores, teniendo en cuenta el numero de subgrupos.

Estos valores vienen identificados por medio de constantes globales y funciones
estáticas que nos devuelven el tipo concreto o los valores padre.
\subsubsection*{Prioridad de la información}
En cada casilla solo podemos almacenar un valor, por lo que la forma de
rellenar la matriz sobreescribe el valor de la matriz si el nuevo valor es
mayor que el viejo. Así nos aseguramos que la información que consideramos mas
prioritaria (de mayor valor) permanezca en la matriz
\subsubsection*{Intersecciones}
A veces es útil sobre todo para las calles saber cuando nos encontramos en un
cruce, para ello cuando nos encontramos un valor igual al que nosotros queremos
inserta, incrementamos en una unidad el valor, haciéndola impar, de esta forma
detectamos las intersecciones.
\subsection*{Coronas}
%mantenimiento actualizado de la corona
Al poder efectuar las simulaciones en mas de un entorno, tenemos que crear un
sistema de actualización a entornos vecinos, para facilitar esto disponemos de
las coronas, las coronas son vectores que contienen información de las casillas
adyacentes de los otros escenarios.

De esta forma, cuando se modifica la información de los limites del escenario,
es la corona la que se encarga de hacer el puente al siguiente escenario y las
actualizaciones necesarias.

De esta forma podemos hacer que los escenarios vean mas halla de su entorno.

\subsection*{Coordenada a Casilla y Viceversa} \label{coordToCasilla}
%conversión de una coordenada a un casilla, necesidad de los incrementos
Para pasar de una casilla a una coordenada utilizamos los incrementos.

\subsubsection*{Incrementos} \label{incrementos}
%perdida de datos, caminos no conexos, indeterminacion de las posisciones
Para poder interpolar la posición desde una casilla a una determinada
coordenada geográfica hemos optado por la técnica de los incrementos en vez de
complicados cálculos trigonométricos terrestres.

La técnica consiste en hallar la diferencia en grados decimales entre los
extremos del mapa y dividirla entre el numero de filas y columnas, con esto
obtenemos el incremento en Latitud o Longitud que hay entre cada casilla de
nuestra rejilla.

Debido a la forma de la rejilla hexagonal tenemos que tener en cuenta que las
filas impares tienen un offset de \begin{math} ^1/_2 \end{math} de un incremento
de latitud, y que las columnas tienen un incremento deEnvironment
\begin{math} ^3/_4 \end{math} el incremento de la longitud.

De esta forma tan sencilla podemos hacer las conversiones de casilla a
coordenada y viceversa.
\subsubsection*{Discretización}
El problema de coordenada a casilla es un poco mas complejo, puesto que al
tener una coordenada tenemos que aproximar a una casilla en concreto, para ello
primero realizamos una aproximación intentando averiguar la casilla en filas y
columnas, sin embargo la forma de las casillas es hexagonal, por lo que la
distancia al centro  no nos asegura que la casilla sea la correcta.

De esta forma perdemos un poco de información, pero los errores cometidos por
este sistema no superan el \begin{math} 0.7\% \end{math}

\subsection*{Especialización: Flood Hexagonal Grid}
%cambios de la rejilla por desastre
\section*{Implementación de la Elevación del Terreno}
%Solucion particular
Usamos los servicios web para extraer las alturas, un bucle por cada casilla
\subsection*{Patrón Fachada} %TODO
%Para poder utilizar todos los servicios web de alturas que hagan falta
Tenemos una fachada para implementar los posibles distintos servicios webs,
tienen que implementar estas funciones, tralaraaaaaa
\subsection*{Cache de alturas}
%Para mejorar la latencia de datos
Los servidores webs suelen ser muy lentos, y el volumen de datos que
necesitamos para la simulación puede ser muy grande.

Obtener todos estos datos cada vez que necesitemos simular un escenario no es
viable.

La solución que nosotros implementamos es almacenar en local los datos para
utilizarlos en posteriores simulaciones o incluso para poder reutilizarlos en
otras simulaciones.

La reutilización de datos se hace por medio de una interpolación (la media de
las casillas adyacentes) de datos en el caso de que nuestra base de datos tenga
la información suficiente.

En nuestra implementación optamos por usar  SQLite\footnote{SQLite Home Page :
\url{www.sqlite.org/}} porque sencillez para la
implementación y por la sencillez de la base de datos en si, que permite poder
moverla de un ordenador a otro con un coste mínimo de instalación al ser un
único fichero el que contiene todos los datos.

El principal problema de SQLite es que no puede albergar muchos datos, pero en
nuestro caso esto se puede resolver creando mas ficheros, y de esta forma
abordamos la escalabilidad.

La base de datos solo contiene una única tabla
\begin{center}
\begin{tabular}{ | l | c | r | }
\hline
Clave & Tipo \\ \hline
Lat & double \\ \hline
Long & double \\ \hline
Elev & double \\ \hline
\end{tabular}
\end{center}


\subsubsection*{Patrón fachada}
%pos una fachada pa poder usar distintos drivers
El diseño de la interfaz para trabajar con servicios web ha sido realizado
teniendo en cuenta el patrón fachada para poder incorporar nuevos servicios web
de altura.

Gracias a este diseño añadir nuevos servicios webs solo tienen el coste de
implementar la clase que cumpla los métodos de la interfaz.
\section*{Open Street Maps}
OSM tiene un servicio web, que a través de mandarle un url correctamente
formada devuelve un fichero XML que contiene toda la información de OSM sobre
unas coordinadas determinadas.

La url se compone de una {\bf Dirección Base} + {\bf Coordenada Inferior
 derecha} + {\bf Coordenada Superior Izquierda} y devolverá un fichero con el
mismo nombre que la petición.
\subsection*{Parseando XML}
%Leer y obtener información
La información viene codificada en un fichero XML siguiendo el estándar de OSM.
Para poder extraer la información es necesario primero parsear el fichero.
Para ello utilizamos JAXB\footnote{Java Architecture for XML Binding :
\url{https://jaxb.dev.java.net/}} que es una librería para recorrer ficheros
XML. 

Mientras realizamos el recorrido del fichero, hay que identificar la
información de las etiquetas y almacenarla en nuestra estructura de datos para
poder utilizarla de una forma mas cómoda.

El diseño de las clases para almacenar la información de OSM es muy parecido a
la jerarquía de información que sigue OSM.

Tenemos la clase principal OsmMap, que contiene toda la información que nos da
OSM.

{\bf OsmWay} para la etiqueta way y {\bf OsmMember} para los caminos
compuestos, {\bf OsmRelation} para los rios y parques, y {\bf OsmNode} para los
puntos simples y puntos de interés. 

Para almacenar la información extra tenemos OsmTag.
\subsubsection*{Filtro de información}
%Quedarnos con la información útil
OsmTag contiene dos atributos principales, clave y valor. Nos valemos de estos
dos atributos para almacenar la información extra que nos ofrece OSM, como el
nombre de la calle, el tipo de calle, o si se trata de un edificio o un parque.

Con esta información podemos determinar de que tipo de objeto estamos tratando
y asignarle un valor concreto en la matriz de calles de cada escenario.

También nos valemos de esta información para filtrar la información.

Hasta ahora hemos optado por quedarnos solo con la información que queremos,
pero si algún día se añade un nuevo tipo de información que no tenemos habría
que añadirlo al filtrado de etiquetas.

También hay etiquetas que reconocemos y que no necesitamos, como por ejemplo,
los limites políticos de las ciudades.

\subsection*{Dibujar Calles}
%De coordenadas a casillas
OSM nos da la información de las calles como listas de puntos que hay que unir
con lineas rectas.

Esto plantea dos problemas.

Uno de ellos lo resolvemos pasando de coordenadas a casillas, como ya hemos
explicado en \hyperref[coordToCasilla]{\bf Coordenada a Casilla}

El otro problema es crear una linea recta mediando dos puntos.
Además hay que tener en cuenta el problema de las rectas en un plano hexagonal.

Para hallar los puntos de las rectas nos valemos de la ecuación de la recta
dados dos puntos, y a través de su pendiente podemos saber cual será el próximo
punto.

Para el problema del mapa hexagonal usamos dos técnicas, la primer es buscar el
siguiente punto de la recta pero con la mitad de distancia de una casilla, así
hacemos los cambios gradualmente y nos aseguramos la conexión del camino con
las casillas.
Pero esto no soluciona el problema de las diagonales, para esto usamos vectores
de direcciones para corregir el rumbo y hacerlo mas adecuado a la malla
hexagonal.

Con esto tenemos mas puntos de los necesarios para pintar una recta, por lo que
al pintarla, guardamos siempre la casilla anterior, y si es la misma, no
pintamos. 

Esto soluciona el problema de las \hyperref[Intersecciones]
{\bf intersecciones}.
\subsection*{Rellenar Figuras}
%Lineas poligonales cerradas y members
Existen tres figuras diferentes a la hora de dibujar los mapas.
Los puntos simples, las lineas rectas y las lineas polinomiales cerradas.

Las lineas polinomiales cerradas se componen de lineas rectas que a su vez son
una sucesión de puntos.

\subsubsection*{Lineas poligonales cerradas}
%los parques y contornos de edificios
Esto es un problema de geometría computacional. Hallar los puntos que encierra
una linea.

Esto es importante si queremos reflejar la extensión de un río o de un parque,
o cualquier otra superficie que ocupe mas de un punto.

Es un problema muy conocido en geometría computacional por lo que hay muchos
algoritmos sencillo que dada una lista de
puntos que describen un polígono te dicen si el punto esta dentro o no.

Por lo que una vez identificadas las lineas cerradas. El primer punto de la
lista, es igual al ultimo punto de la lista. Simplemente hay que aplicar el
algoritmo y rellenar las zonas con el valor adecuado.
\subsubsection*{Relaciones}
%rios, mares ....
Sin embargo existen otras figuras mas complejas, como las orillas de los rios,
o las costas. OSM también nos da esta información, pero no es tan sencillo de
interpretar ya que solo nos dice que es una orilla, y que pertenece a un rio en
concreto.
Pero dadas dos orillas del mismo río, como se cual es cual y en que dirección
hay que rellenar el agua. O peor aún, y si en nuestro mapa, solo tenemos una
orilla del río.

OSM ya provee este problema, y cuando pedimos la información de un lugar, no da
también información de los alrededores, y si en nuestra zona solo aparece una
orilla del río, OSM nos da la información también de la otra orilla.

De esta forma, podemos calcular el cauce del río aunque este fuera de nuestro
mapa, y pintar solo aquellas regiones que estén dentro del mismo.

Una vez mas la forma que tiene OSM de organizar los datos nos da la solución,
porque simplemente encadenando la información de las dos orillas del río nos da
la figura que envuelve a las dos orillas del río.

Para la Costa y otras formaciones de agua o figuras complejas es equivalente.
\subsection*{Intersecciones de Caminos} \label{Intersecciones}
Además del tipo de camino que estamos guardando en la matriz de calles del
escenario, podemos almacenar de una forma inteligente información sobre las
calles, como por ejemplo si una casilla en concreto forma parte de una
intersección de calles, sin tener que mirar las casillas adyacentes. La forma
de solucionar esto es simplemente dándoles por defecto una valor par a todos
los tipos de caminos, y si alguna vez un camino se cruza (siempre y cuando sea
de su mismo tipo) se guarda esta casilla con un valor impar.

De esta manera tan simple, podemos identificar y almacenar las calles que
conectan con otras calles.

\section*{Generador de KML}
Para general los archivos KML utilizamos
JAK\footnote{JAK Java API for KML :
\url{http://labs.micromata.de/display/jak/Home}}.
\subsection*{Múltiples Escenarios}
%Soporte para varios escenarios
El visor de KML puede recibir información de varios escenarios, ya que al estar
todo geolocalizado, no tengo problema de integrar múltiples
escenarios, salvo por el volumen de datos.
\subsection*{Secuencia de Tiempo}
%Soporte para la temporalidad de los eventos
Para podes simular la simulación fielmente necesito una marca de tiempo, para
ello tenemos que llevar un control del tiempo real en la simulación, 
%TODO enlace a clokagent
\subsection*{KmlPolygon}
%Agrupar poligonos por altura
Al igual que creamos una clase para tratar la información de OSM, creamos una
clase amigable para tratar los polígonos en KML.

Toda la información de la simulación la tenemos que representar por medio de
polígonos en el KML. La cual nos facilita la creación y la asignación de las
propiedades que queremos que tenga nuestro polígono.

Para ello contamos con la posición, la forma, la altura del polígono, el color,
y la transparencia.

Haciendo un buen uso de estas características podemos expresar mucha
información de una forma eficaz y elegante.
\subsubsection*{Bordes}
Tenemos dos problemas, las posiciones de los polígonos nos vienen dadas a
través de un única coordenada, pero nosotros para dibujar el polígono
necesitamos conocer los bordes.

Esto se hace simplemente con los \hyperref[incrementos]{\bf incrementos} y un
poco de trigonometría.

El otro problema que tenemos es mucho mas grande y es precisamente ese, el
tamaño.

La simulación produce mucha información que reflejar en un solo archivo. Por
cada casilla inundada son 7 coordenadas, si eso lo multiplicamos por las
casillas inundadas y por el numero de instantáneas y que todo eso va almacenado
en un fichero KML acabamos teniendo ficheros de tamaño muy considerable, que al
ser representados por un visor nos da un límite de información.

Para poder almacenar la mayor cantidad posible de datos, usamos la versión KMZ
de los archivos, (que no es mas que versiones comprimidas en zip de los
archivos KML) y además una agrupación de casillas inundadas al mismo nivel.

Esto quiere decir, que si tenemos un conjunto de casillas adyacentes que con el
mismo nivel en la inundación, estas casillas pasan a 1 único polígono y solo
tendríamos que almacenar el valor de su perímetro, no de todas las casillas que
lo contienen.

Con este sistema condensaremos mucha información debido a la naturaleza del
agua, a permanecer a un nivel determinado.

Para ello hacemos uso otra vez de conocimientos de geometría computacional y
del operador borde, en este caso, con el que podemos hallar el borde de
cualquier figura.

Para detectar los bordes y sobre todo escribirlos en el orden correcto,
utilizamos el operador borde (elimina los opuestos) y las listas de adyacentes.

Asumimos que la lista de adyacentes mas larga es el borde exterior
\subsubsection*{Color y Transparencia}
%decidimos usar hexagonos de distintos colores
Como ya comentamos antes, nos valemos del color para representar información de
manera intuitiva. Azul para el agua, Verde para personas a salvo ... etc.

KML permite asignarle color a las figuras de forma nativa, así que simplemente
creamos unos estilos predefinidos, y los asignamos a los polígonos.

El color se calcula para cada uno de los objetos, y es común para los objetos
equivalentes. 

Para el agua, si un polígono tiene la
misma altura de agua, todos tendrán el mismo color y transparencia por ser
equivalentes.

Para las personas igual, les asignamos colores (y una altura de 5 metros para
que sean fácilmente identificables) y ninguna transparencia.
Así tenemos que las personas que están en refugios tendrán el color verde, las
personas que se encuentren en peligro tendrán el color amarillo, y las personas
que se hallen atrapadas o muertas tendrán color gris.

Con este sencillo método podemos representar la información de manera muy
visual y expresiva.
\section*{Visor Bidimensional}
\subsection*{Múltiples escenarios}
\section*{Estadísticas}
Siguiendo la misma estrategia que los demás objetos que se actualizan
periódicamente, hemos diseñado un agente estadístico que se encarga de recoger
información de cada estado de la simulación.

Recogiendo la información deseada, en nuestro caso, el estado de las personas,
y el tiempo de la simulación, podemos hacer una evaluación estadística de la
evolución de la inundación, sabiendo cuales han sido las zonas donde mas
personas han perecido, o salvado y la hora en la que sucedió.
\subsection*{Múltiples Escenarios}
%Soporte para varios escenarios
Nuestra simulación puede tener mas de un escenario, por ello necesitamos
identificar de que escenario estamos recogiendo los datos, esto lo realizamos
simplemente añadiendo una columna con el identificador del escenario.
\subsection*{Ficheros CVS}
%Es lo mas comodo para las estadisticas
Los ficheros CSV\footnote{Valores Separados por Coma :
\url{http://es.wikipedia.org/wiki/CSV}} son muy fáciles de escribir y leer y la
forma mas simple de almacenar información. Por ello los hace ideales para
nuestro propósito de recoger una serie de estadísticas y guardarlas en un
fichero que sigue una forma estándar de almacenar los datos y que es reconocida
por la mayoría de hojas de cálculo y fácilmente se pueden generar gráficas a 
partir de estos ficheros.
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../dissim"
%%% End: